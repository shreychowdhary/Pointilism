// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Pointilism

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

int width;
int height;
int skipWidth;
float thickness;
float length;

struct Vertex {
    float3 pos;
    float4 color;
};

RWStructuredBuffer<Vertex> vertices;
RWStructuredBuffer<float2> gradient;
Texture2D<float4> source;
RWTexture2D<float4> destination;
Texture2D<float4> depth;

float random(float2 st) {
    return frac(sin(dot(st.x,float2(12.9898, 78.233))) * 43758.5453123);
}

bool IsClockwise(float2 a, float2 b, float2 c) {
   return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y) < 0;
}

[numthreads(32,32,1)]
void Pointilism (uint3 id : SV_DispatchThreadID) {
    int x = id.x;
    int y = id.y;
    float dx = gradient[id.y*width+id.x].x;
    float dy = gradient[id.y*width+id.x].y;
    float3 grad = float3(dx,dy,0);
    float mag = dx*dx+dy*dy;
    gradient[id.y*width+id.x] = grad.xy;
    destination[id.xy] = float4(mag,mag,mag,1);

    float3 dir = length * normalize(float3(-grad.y, grad.x,0));
    float3 perp = thickness * normalize(grad);
    int index = id.y*width+id.x;
    if (index%skipWidth == 0) {
        Vertex v0, v1, v2, v3;
        //TODO find way to make bigger lines go in front
        
        float3 a = float3(2*(x/(float)width)-1,2*(y/(float)height)-1, clamp(depth[id.xy].r,0,1));
        float3 b = a + dir;
        v0.pos = a - perp;
        v1.pos = a + perp;
        v2.pos = b + perp;
        v3.pos = b - perp;
        v0.color = source[id.xy];
        v1.color = source[id.xy];
        v2.color = source[id.xy];
        v3.color = source[id.xy];
    
        vertices[6*index/skipWidth] = v0;
        vertices[(6*index/skipWidth)+1] = v1;
        vertices[(6*index/skipWidth)+2] = v2;
        vertices[(6*index/skipWidth)+3] = v2;
        vertices[(6*index/skipWidth)+4] = v3;
        vertices[(6*index/skipWidth)+5] = v0;

       
        if (!IsClockwise(v0.pos,v1.pos,v2.pos)) {
            vertices[(6*index/skipWidth)+1] = v2;
            vertices[(6*index/skipWidth)+2] = v1;
        }
        if (!IsClockwise(v2.pos,v3.pos,v0.pos)) {
            vertices[(6*index/skipWidth)+4] = v0;
            vertices[(6*index/skipWidth)+5] = v3;
        }
    }
}
