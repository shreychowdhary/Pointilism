#pragma kernel Sobel

int width;
int height;

int skipWidth;

float thickness;
float length;

bool blur;

struct Vertex {
    float3 pos;
    float4 color;
};

RWStructuredBuffer<Vertex> vertices;

Texture2D<float4> source;
RWTexture2D<float4> destination;

float random(float2 st) {
    return frac(sin(dot(st.x,float2(12.9898, 78.233))) * 43758.5453123);
}

float Grayscale(float4 color) {
    return dot(color.rgb, float3(0.2989,0.5870,0.1140));
}

bool IsClockwise(float2 a, float2 b, float2 c) {
   return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y) < 0;
}

[numthreads(30,30,1)]
void Sobel (uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int y = id.y;
    if (id.x > 0 && id.y > 0 && id.x < width-1 && id.y < height-1) {
        float dx = -Grayscale(source[id.xy+float2(-1,-1)])-2*Grayscale(source[id.xy+float2(-1,0)])-Grayscale(source[id.xy+float2(-1,1)])
            +Grayscale(source[id.xy+float2(1,-1)])+2*Grayscale(source[id.xy+float2(1,0)])+Grayscale(source[id.xy+float2(1,1)]);
        
        float dy = Grayscale(source[id.xy+float2(-1,-1)])+2*Grayscale(source[id.xy+float2(0,-1)])+Grayscale(source[id.xy+float2(1,-1)])
            -Grayscale(source[id.xy+float2(-1,1)])-2*Grayscale(source[id.xy+float2(0,1)])-Grayscale(source[id.xy+float2(1,1)]);
        
        destination[id.xy] = float4(dx, dy, 0, 1);

        if (blur) {
            GroupMemoryBarrierWithGroupSync();

            dx = destination[id.xy + float2(-1, -1)].x + 2 * destination[id.xy + float2(0, -1)].x + destination[id.xy + float2(1, -1)].x
                + 2 * destination[id.xy + float2(-1, 0)].x + 4 * destination[id.xy + float2(0, 0)].x + 2 * destination[id.xy + float2(1, 0)].x
                + destination[id.xy + float2(-1, 1)].x + 2 * destination[id.xy + float2(0, 1)].x + destination[id.xy + float2(1, 1)].x;

            dy = destination[id.xy + float2(-1, -1)].y + 2 * destination[id.xy + float2(0, -1)].y + destination[id.xy + float2(1, -1)].y
                + 2 * destination[id.xy + float2(-1, 0)].y + 4 * destination[id.xy + float2(0, 0)].y + 2 * destination[id.xy + float2(1, 0)].y
                + destination[id.xy + float2(-1, 1)].y + 2 * destination[id.xy + float2(0, 1)].y + destination[id.xy + float2(1, 1)].y;


            dx = dx/16;
            dy = dy/16;
        }
        float mag = sqrt(dx * dx + dy * dy);
        destination[id.xy] = float4(mag,mag,mag, 1);

        if (mag < 0.01) {
            dx = random(id.xy);
            dy = random(id.yx);
            mag = sqrt(dx * dx + dy * dy);
        }
        float3 grad = float3(dx, dy, 0) / mag;
        float3 dir = (length+length * sqrt(mag))* float3(-grad.y, grad.x,0);
        float3 perp = thickness * grad;
        int index = (id.y-1)*(width-2)+(id.x-1);
        if (index%skipWidth == 0) {
            Vertex v0, v1, v2, v3;
            float3 offset = normalize(float3(random(source[id.xy].rg), random(source[id.xy].gb),random(source[id.xy].rb)))*length*.3;
            float3 a = float3(2*((x-1)/(float)(width-2))-1,2*((y-1)/(float)(height-1))-1,0);
            float3 b = a + dir;
            v0.pos = a - perp;
            v1.pos = a + perp;
            v2.pos = b + perp;
            v3.pos = b - perp;
            v0.color = source[id.xy];
            v1.color = source[id.xy];
            v2.color = source[id.xy];
            v3.color = source[id.xy];
        
            vertices[6*index/skipWidth] = v0;
            vertices[(6*index/skipWidth)+1] = v1;
            vertices[(6*index/skipWidth)+2] = v2;
            vertices[(6*index/skipWidth)+3] = v2;
            vertices[(6*index/skipWidth)+4] = v3;
            vertices[(6*index/skipWidth)+5] = v0;

            if (!IsClockwise(v0.pos,v1.pos,v2.pos)) {
                vertices[(6*index/skipWidth)+1] = v2;
                vertices[(6*index/skipWidth)+2] = v1;
            }

            if (!IsClockwise(v2.pos,v3.pos,v0.pos)) {
                vertices[(6*index/skipWidth)+4] = v0;
                vertices[(6*index/skipWidth)+5] = v3;
            }
            
        }
    }
    
}

